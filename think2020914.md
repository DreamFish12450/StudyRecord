# 顶层索引设计

## HashMap

第一点的话他底层的数据结构是红黑树加链表加数组

其内部节点的话是用数组存储。而链表则是在处理哈希的冲突时。而红黑树则是链表的升级当哈希冲突过多的时候则会出现红黑树

hashmap的put是做一个覆盖值

且需要注意的是hashmap的扩容的代价很大 所以建议初始化一个值。

hashmap 最致命的一点也就是他的存储是较为随机的。也就是怎么说没有顺序的。但是他在查找单个数据时的效率，或者进行增删改的效率是极高的。也就是我为什么不用TreeMap。而TreeMap则适合按照一定顺序（或者排序）遍历的效率较高。

这个时候作为hashmap的子类`LinkedHashMap`就出来了。他能保证可以按照数据被放入的顺序有序的遍历这些数据。而我们的使用场景也刚好是每次插入的数据都是有序的。所以就可以利用这个来作为顶层索引的底层设计。

## LinkedHashMap

LinkedHashMap有`插入顺序`和`访问顺序`。后一种的排序方法感觉可以在负载均衡的时候用一下，具体的使用场景没有想过。

其主要特点在于每个元素有`after`和`before`两个指针。当其每次put一个元素的时候会去维护这个双向链表。

其实这里做的话就是把这个新元素加到最后面

同时其在扩容的时候也会直接去遍历这个双向链表因此效率高于普通的hashmap


## why concurrentSkipListMap

为什么要用跳表呢一是其查询较快。二是其支持一定的范围查询。但是其在增加节点上效率较差。

 ConcurrentSkipListMap可确保各种操作的平均O（log（n））性能。虽然他快。但他还是比hashmap会慢挺多的。

 但是这个ConCurrentSkipListMap他是可导航的也是比较支持连续的查询的。同时他也有着原生的范围查询函数（应该是来自ConcurrentNavigableMap）的subMap（fromKey,toKey），headMap(toKey), tailMap(fromKey) 这三个查询函数。

 好像他对计算机的缓存机制利用的效率比较高。

 还有一点可能不被用到就是其是线程安全的。就是在并行的时候效果比较好。

 同时他虽然添加节点比较麻烦但还是会比B+树那种可能出现分裂的看起来效率更高点